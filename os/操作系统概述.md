# 操作系统原理_清华大学

### uCore
### https://github.com/chyyuu/mooc_os_lab

### 操作系统实验

- 实验0:准备
- 实验1:系统启动及终端
- 实验2:物理内存管理
- 实验3:虚拟内存管理
- 实验4:内核线程管理
- 实验5:用户进程管理
- 实验6:CPU调度
- 实验7:同步与互斥
- 实验8:文件系统

### 预备知识

- 计算机结构原理(Intel 80386)
- 数据结构
- C和汇编语言

### 什么是操作系统

#### 用户角度上()

- 操作系统是一个软件
- 管理应用程序
- 为应用程序提供服务
- 杀死应用程序

#### 资源管理

- 管理外设、分配资源

操作系统

物理硬件         操作系统
cpu---[抽象]---->进程
磁盘---[抽象]---->文件
内存---[抽象]---->地址空间

#### 操作系统架构层次结构

- 操作系统在硬件之上 
- 操作系统在应用程序之下
    - 应用软件:办公软件、视频播放软件
    - 操作系统位于应用软件之下、为应用软件提供服务支撑
- Linux、Windows、Android的界面属于外壳(shell)、而不是内核(Kernel),Kernel是我们的研究重点、在shell之下

user <=[ shell [os Kernel] shell ]=> user 

- Kernel操作系统内部组件
    - CPU调度器
    - 物理内存管理
    - 虚拟内存管理
    - 文件系统管理
    - 中断处理与设备驱动
- OS Kernel的特征
    - 并发
        - 计算机系统中同时存在多个运行的程序、需要OS管理和调度
        - 并发:一段时间内多个程序可以运行
        - 并行:一个时间点内多个程序运行(一般需要计算机有多个cpu)
    - 共享
        - "同时"访问(分时)
        - 互斥共享(把资源分为多份,每个应用程序一份)
    - 虚拟
        - cpu虚拟化为进程
        - 磁盘虚拟化为文件
        - 内存虚拟化为地址空间
        - 利用多道程序设计技术、让每个用户都觉得有一个计算机专门服务(一台机器虚拟为多台机器)
    - 异步
        - 程序的执行不是一贯到底、而是走走停停、向前推进的速度不可预知
        - 但是要运行环境相同、OS需要保证程序运行的结果也要要相同


### 为什么要去学习操作系统

- 综合课程:结合许多不同的课程
    - 程序设计语言
    - 数据结构
    - 算法
    - 计算机体系结构
    - 材料
    - 操作系统概念和原理、源代码
    - 技能
    - 操作系统的设计和实现
- 已经有了很多操作系统
    - Windows
    - Linux
- 为什么要学习操作系统
    - 操作系统在不停地发展、在工控等各个领域有强烈的需求
    - 操作系统很酷、很有用、有挑战
- 操作系统:计算机科学研究基石之一
    - 计算机系统的基本组成部分
    - 有硬件的发展和应用需求所驱动
    - 学术和工业的持续推进
- 顶尖大学的计算机科学
- 工业界
    - 微软、谷歌、Facebook
- 学术界
    - ACM
    - IEEE
    - USENIX
    - 国内:CCF
- 顶级会议
    - SOSP(每两年,1967-...)
    - USENIX(每两年,1994-...)

- 操作系统的挑战
    - 操作系统很大
    - 实际操作系统
    - 操作系统并发管理
        - 并发导致又去的编程错误
    - 操作系统代码管理原始硬件
        - 时间依赖行为、非法行为、硬件故障
    - 操作系统代码必须是高效的
        - 低耗CPU、内存、磁盘
    - 操作系统出错就意味着机器出错
        - 操作系统必须必用户程序拥有更高的稳定性
    - 操作系统是安全的基础
    - 有些内容已经由硬件本身解决了不需要操作系统解决
        - 磁盘IO调度可有硬件本身管理
    - 系统操作需要权衡
        - 时间与空间
        - 性能和可预测性
            - 性能高且程序什么时候开始什么时候结束都能预测
        - 公平和性能
            - 资源被高效使用
    - 硬件方面、操作系统需要
        - 良好的硬件管理
        - 合理的资源分配
        - eg:硬盘速度跟CPU、内存相差很多、操作系统需要协调处理

### 如何学习操作系统

> 动手

### 操作系统实例

- 面向桌面
- 面向移动终端
- UNIX
- Linux家族
- Windows家族

### 操作系统的历史

### 操作系统的结构

- 微内核的设计,尽可能吧内核功能移到用户控件
    - 内核只放最基本的功能
        - 中断处理
        - 消息传递
        - 像文件系统、内存管理、网络协议以服务的形式存在
    - 代价就是性能



### 操作系统的启动 2020-03-24


- 启动

Disk:存放OS
BIOS:基本的IO处理系统
```
BIOS的功能就是一打开电源就可以检测各种外设
```

BootLoader:加载OS 让os从磁盘到内存让CPU执行操作系统

```
内存:
_________________________________
| Free space| BOIS | Free space |
---------------------------------

DISK:
_________________________________
|          BootLoader   |  OS   |
---------------------------------

CS:IP = 0xf0000:fff0
(CS:段寄存器;IP指令寄存器)
BIOS从这个地址开始执行以及一系列操作如
```
- POST(加点自检)
    - 检测外设
- 把BootLoader放进内存中

```
大致过程为
BIOS将BootLoader加载内存(0x7c00)
然后BIOS将cpu的执行权限给BootLoader
BootLoader将OS的代码和数据加载内存中
然后BootLoader将cpu执行权限交给OS
OS从其实位置开始执行初始化操作
```

### 操作系统与设备和程序交互

#### 系统调用、异常、中断

- 系统调用(来源于应用程序)
    - 应用程序主动向操作系统发出服务请求
- 异常(来源于不亮的应用程序)
    - 非法指令或者其他坏的处理状态(eg:内存出错)
- 终端(来源于外设)
    - 来自不同的硬件设备的计时器和网络中断
        - eg:U盘插入电脑时操作系统需要处理

- 为什么不让第三方软件之间访问外设？
    - 计算机运行中、内核是被信任的第三方
    - 只有内核可以执行特权命令
    - 为了我方便应用程序

- 操作系统如何设计和实现异常、中断
    - 源头
        - 中断:外设
        - 异常:应用程序想不到的行为
        - 系统调用(sys call):应用程序请求操作系统提供服务
            - 应用程序提出
    - 处理时间
        - 中断:异步
        - 异常:同步
            - 执行到某些错误时操作系统处理
        - 系统调用:同步或异步
    - 响应
        - 中断:持续、对哦用户应用程序是透明的
        - 异常:杀死或者重新执行意想不到的应用程序指令
        - 系统调用:等待和持续

#### 中断和异常的处理机制

##### 中断

```
中断表有编号和中断类型
中断就是打断了正常的程序执行而去处理一个更紧急的任务
此时软件和硬件都需要有恢复机制
```

- 硬件
    - 设置中断标记[CPU初始化]
        - 1、讲内部、外部事件设置中断标记
        - 2、中断的事件ID
        - 3、将中断的ID发给操作系统供操作系统处理
- 软件
    - 保存当前的处理状态
        - eg:执行到代码位置
    - 中断服务程序处理
        - 根据外设的中断ID做相应的处理
    - 清除中断标记
    - 回复之前保存的处理状态

#### 异常

- 异常：异常编号
    - 保存现场
    - 异常处理
        - 杀死产生了异常的程序
        - 重新执行异常指令
    - 回复现场

#### 系统调用

```
有些操作不能由第三方应用程序直接执行
而是由操作系统来执行(为了安全)
操作系统有留一些借口方便应用程序使用
应用程序使用这些借口的过程就叫做系统调用

eg:c语言调用print() 会触发系统调用write()操作
做完处理操作系统会返回一个结果表示成功或者失败
```

- 程序访问主要是通过高层次的API接口而不是直接系统调用
    - eg:Win32 API用于Windows
    - POSIX API用于POSIX-based systems
    - Java Api用于JAVA虚拟机
        - java Api调用java虚拟机的API java虚拟机再调用Linux/Windows API

- 通常情况下、与每个系统调用相关的序号
    - 系统调用接口根据这些序号来维护表的索引
- 系统调用接口 接口调用内核中预期的系统调用
    - 并返回系统调用的状态和其他任何返回值
- 用户不需要知道系统调用是如何实现的
    - 只需要获取API和了解操作系统将会返回什么结果
    - 操作系统接口的细节大部分都隐藏在API中
        - 通过运行程序支持的库来管理(用包括编译器的库来创建函数集) 

```
应用程序通过lib做系统调用的接口
会出发用户态到内核态的转换
用户态:应用程序执行中cpu所出的一种权限状态，特权级较低，不能直接访问一些操作比如IO操作
内核态:可以完全控制整个计算机可以执行任何命令
从用户态转换到内核态cpu的执行权由应用程序转换到操作系统手中
操作系统通过系统调用的ID执行操作
```


#### 函数调用 vs 系统调用

- 函数调用
    - 快
    - 开销小
        - 所有的操作执行都在一个堆栈中不需要做堆栈的切换
    - 不安全
- 系统调用
    - 慢
    - 开销大
        - 需要做用户态和内核态的切换、堆栈也会切换
    - 安全可靠


- 跨越操作系统边界的开销
    - 在执行时间上的开销超过系统调用
    - 开销
        - 建立中断/异常/系统调用过程与对应的服务
            - 例如程序映射关系的初始化开销
        - 建立内核堆栈
        - 验证参数
        - 内核映射到哦用户态的地址空间
            - 更新页面映射权限
        - 内核态独立地址空间TLB

#### 3.1 计算机体系结构及内存分层体系

- 内存的层次结构

```
微处理器                内存延迟

________________
|   |  CPU  |  |
|   | L1缓存 |  |
----------------
|   | L2缓存 |  |
————————————————

_________________
|       主存     |
—————————————————

_________________
|  磁盘(虚拟内存) |
—————————————————
```

##### 操作系统管理物理内存中做的事情

- 抽象
    - 逻辑地址空间
- 保护
    - 多个应用程序之间独立地址空间
- 共享
    - 访问相同的内存 
- 虚拟化
    - 更多的地址空间(把暂时不需要的数据先放入磁盘)
    - 有些程序正在等待某些过一会才会发生的事情，此时就可以把这个程序放入磁盘(虚拟内存)


##### 操作系统管理内存的不同方法

- 程序重定位
- 分段
- 分页
- 虚拟内存
- 按需分页虚拟内存

##### 实现高度依赖于硬件

- 必须知道内存架构
- MMU(内存管理单元):硬件组件负责处理CPU的内存访问请求

#### 3.2 地址空间 & 地址生成

- 地址空间定义
    - 物理地址空间:硬件支持的地址空间
    - 逻辑地址空间:运行中的程序所拥有的内存范围
- 地址生成
    - 逻辑地址生成
        - 为符号和函数名分配地址
        - 多个汇编文件相互调用时使用Linker把多个文件中的符号统一编号
    - 物理地址生成
    ```
        1、CPU中的运算器需要逻辑地址对应的内容
        2、CPU中的MMU(内存管理单元)获取逻辑地址与物理地址的映射
        3、CPU从总线发送物理地址请求
        4、内存将物理地址通过总线发送给CPU
        操作系统来维护这个映射关系表
    ```
- 地址安全检查

```
操作系统需要控制多个程序有独立的内存，程序之间不能相互干扰
操作系统设置每个程序的基址和界限
```


#### 3.3 连续的内存分配:内存碎片与分区的动态分配


- 第一适配
- 最佳适配
- 最差适配
- 压缩式碎片整理
- 交换式碎片整理


- 内存碎片问题:空闲内存不能被利用
    - 外碎片:在分配单元之间的未被使用的内存
    - 内碎片:分配给应用程序的内不能使用的内存

##### 分区的动态分配

- 简单内存管理方法
    - 当一个程序准许运行在内存中时，分配一个连续的区间
    - 分配一个连续的内存区间给运行的程序以访问数据

##### 分区的动态分配策略(算法)

#### 第一适配
```
    基本原理 & 实现
    按照地址排序的空闲列表分配一块合适的分区
    重分配需要检查看自由分区能否合并于相邻的空闲分区
    优势
        简单
        易于产生更大的空闲块
    劣势
        外部碎片严重
        太多的不确定性
```


##### 最佳适配
```
相比于首次适配会选择和需要分配的相差最小的块

优势
    大部分分配是尺寸嘴合适的
    比较简单
劣势
    外部碎片
    重分配慢
    易产生很多没用的微小碎片
```


##### 最差适配
```
相比于最佳适配会选择与需要分配的想比相差最大的
优势
    加入分配是中等尺寸效果最好
劣势
    重分配慢
    外部碎片
    易于破坏大的空闲块以致大分区无法被分配
```


#### 3.4 连续的内存分配:压缩式与交换式碎片整理

##### 压缩式碎片整理
```
重置程序以合并空洞
要求所有程序是动态可重置的
议题
    - 合适重置
    - 开销
```

##### 交换式碎片整理

```
把等待资源的程序P1暂时放入硬盘从而腾出空间
当P1需要执行时可能别的程序已经不需要内存了
再把内存留给P1

运行程序需要更多的内存
抢占等待的程序&回收他们的内存
```